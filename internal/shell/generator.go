package shell

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/rztaylor/GoDotFiles/internal/apps"
)

// Generator generates shell integration scripts.
type Generator struct{}

// GenerateOptions controls optional shell generation behavior.
type GenerateOptions struct {
	// EnableAutoReload appends shell prompt hooks that re-source init.sh after updates.
	EnableAutoReload bool
}

// NewGenerator creates a new shell generator.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate generates a shell integration script from app bundles.
// globalAliases contains aliases not associated with any app bundle.
func (g *Generator) Generate(bundles []*apps.Bundle, shellType ShellType, outputPath string, globalAliases map[string]string) error {
	return g.GenerateWithOptions(bundles, shellType, outputPath, globalAliases, GenerateOptions{})
}

// GenerateWithOptions generates a shell integration script from app bundles with optional behavior.
func (g *Generator) GenerateWithOptions(bundles []*apps.Bundle, shellType ShellType, outputPath string, globalAliases map[string]string, opts GenerateOptions) error {
	if shellType == Unknown {
		return fmt.Errorf("cannot generate script for unknown shell type")
	}

	// Build script content
	var script strings.Builder

	// Header
	script.WriteString(g.generateHeader(shellType))

	// Aliases
	aliases := g.generateAliases(bundles, globalAliases)
	if aliases != "" {
		script.WriteString("\n# Aliases\n")
		script.WriteString(aliases)
	}

	// Environment variables
	envVars := g.generateEnvVars(bundles)
	if envVars != "" {
		script.WriteString("\n# Environment variables\n")
		script.WriteString(envVars)
	}

	// Functions
	functions := g.generateFunctions(bundles)
	if functions != "" {
		script.WriteString("\n# Functions\n")
		script.WriteString(functions)
	}

	// Init
	initSnippets := g.generateInit(bundles, shellType)
	if initSnippets != "" {
		script.WriteString("\n# Init\n")
		script.WriteString(initSnippets)
	}

	// Completions
	completions := g.generateCompletions(bundles, shellType)
	if completions != "" {
		script.WriteString("\n# Completions\n")
		script.WriteString(completions)
	}

	if opts.EnableAutoReload {
		autoReload := g.generateAutoReload(shellType)
		if autoReload != "" {
			script.WriteString("\n# Auto-reload\n")
			script.WriteString(autoReload)
		}
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write to file
	if err := os.WriteFile(outputPath, []byte(script.String()), 0644); err != nil {
		return fmt.Errorf("failed to write shell script: %w", err)
	}

	return nil
}

// generateHeader generates the shell script header.
func (g *Generator) generateHeader(shellType ShellType) string {
	var shebang string
	switch shellType {
	case Bash:
		shebang = "#!/bin/bash"
	case Zsh:
		shebang = "#!/bin/zsh"
	default:
		shebang = "#!/bin/sh"
	}

	return fmt.Sprintf(`%s
# Generated by gdf - DO NOT EDIT MANUALLY
# This file is regenerated automatically by 'gdf apply'
`, shebang)
}

// generateAliases generates alias definitions from bundles and global aliases.
// App bundle aliases take precedence over global aliases with the same name.
func (g *Generator) generateAliases(bundles []*apps.Bundle, globalAliases map[string]string) string {
	// Start with global aliases (app aliases override these)
	aliases := make(map[string]string)
	for name, cmd := range globalAliases {
		aliases[name] = cmd
	}
	// App aliases override global ones
	for _, bundle := range bundles {
		if bundle.Shell == nil || bundle.Shell.Aliases == nil {
			continue
		}
		for name, cmd := range bundle.Shell.Aliases {
			aliases[name] = cmd
		}
	}

	if len(aliases) == 0 {
		return ""
	}

	// Sort by alias name for deterministic output
	names := make([]string, 0, len(aliases))
	for name := range aliases {
		names = append(names, name)
	}
	sort.Strings(names)

	var out strings.Builder
	for _, name := range names {
		fmt.Fprintf(&out, "alias %s='%s'\n", name, aliases[name])
	}

	return out.String()
}

// generateEnvVars generates environment variable exports.
func (g *Generator) generateEnvVars(bundles []*apps.Bundle) string {
	// Collect all env vars (last bundle wins for duplicates)
	envVars := make(map[string]string)
	for _, bundle := range bundles {
		if bundle.Shell == nil || bundle.Shell.Env == nil {
			continue
		}
		for name, value := range bundle.Shell.Env {
			envVars[name] = value
		}
	}

	if len(envVars) == 0 {
		return ""
	}

	// Sort by variable name for deterministic output
	names := make([]string, 0, len(envVars))
	for name := range envVars {
		names = append(names, name)
	}
	sort.Strings(names)

	var out strings.Builder
	for _, name := range names {
		fmt.Fprintf(&out, "export %s=\"%s\"\n", name, envVars[name])
	}

	return out.String()
}

// generateFunctions generates shell function definitions.
func (g *Generator) generateFunctions(bundles []*apps.Bundle) string {
	// Collect all functions (last bundle wins for duplicates)
	functions := make(map[string]string)
	for _, bundle := range bundles {
		if bundle.Shell == nil || bundle.Shell.Functions == nil {
			continue
		}
		for name, body := range bundle.Shell.Functions {
			functions[name] = body
		}
	}

	if len(functions) == 0 {
		return ""
	}

	// Sort by function name for deterministic output
	names := make([]string, 0, len(functions))
	for name := range functions {
		names = append(names, name)
	}
	sort.Strings(names)

	var out strings.Builder
	for _, name := range names {
		body := functions[name]
		fmt.Fprintf(&out, "%s() {\n  %s\n}\n\n", name, body)
	}

	return out.String()
}

// generateCompletions generates shell completion loading commands.
func (g *Generator) generateCompletions(bundles []*apps.Bundle, shellType ShellType) string {
	var completions []string

	for _, bundle := range bundles {
		if bundle.Shell == nil || bundle.Shell.Completions == nil {
			continue
		}

		var cmd string
		switch shellType {
		case Bash:
			cmd = bundle.Shell.Completions.Bash
		case Zsh:
			cmd = bundle.Shell.Completions.Zsh
		}

		if cmd != "" {
			completions = append(completions, cmd)
		}
	}

	if len(completions) == 0 {
		return ""
	}

	var out strings.Builder
	for _, cmd := range completions {
		// Wrap in command check for safety
		fmt.Fprintf(&out, "if command -v %s &> /dev/null; then\n", extractCommand(cmd))
		fmt.Fprintf(&out, "  source <(%s)\n", cmd)
		fmt.Fprintf(&out, "fi\n")
	}

	return out.String()
}

// generateInit generates shell startup snippets from app bundles.
func (g *Generator) generateInit(bundles []*apps.Bundle, shellType ShellType) string {
	var out strings.Builder
	hasInit := false

	for _, bundle := range bundles {
		if bundle.Shell == nil || len(bundle.Shell.Init) == 0 {
			continue
		}

		for _, snippet := range bundle.Shell.Init {
			cmd := snippet.Common
			switch shellType {
			case Bash:
				if snippet.Bash != "" {
					cmd = snippet.Bash
				}
			case Zsh:
				if snippet.Zsh != "" {
					cmd = snippet.Zsh
				}
			}

			if cmd == "" {
				continue
			}

			hasInit = true
			fmt.Fprintf(&out, "# %s:%s\n", bundle.Name, snippet.Name)
			if snippet.Guard != "" {
				fmt.Fprintf(&out, "if %s; then\n", snippet.Guard)
				writeIndentedLines(&out, cmd, "  ")
				out.WriteString("fi\n")
			} else {
				writeIndentedLines(&out, cmd, "")
			}
		}
	}

	if !hasInit {
		return ""
	}
	return out.String()
}

func writeIndentedLines(out *strings.Builder, script, indent string) {
	lines := strings.Split(script, "\n")
	for _, line := range lines {
		if line == "" {
			out.WriteString("\n")
			continue
		}
		out.WriteString(indent)
		out.WriteString(line)
		out.WriteString("\n")
	}
}

// extractCommand extracts the first word from a command string.
func extractCommand(cmd string) string {
	parts := strings.Fields(cmd)
	if len(parts) > 0 {
		return parts[0]
	}
	return cmd
}

// ExportAliases generates a file containing all aliases from bundles and global aliases.
func (g *Generator) ExportAliases(bundles []*apps.Bundle, globalAliases map[string]string, outputPath string) error {
	aliases := g.generateAliases(bundles, globalAliases)
	if aliases == "" {
		aliases = "# No aliases found\n"
	}

	// Add header
	content := "# Aliases exported by GDF restore\n" + aliases

	// Write to file
	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing aliases file: %w", err)
	}
	return nil
}

func (g *Generator) generateAutoReload(shellType ShellType) string {
	switch shellType {
	case Bash:
		return `
_gdf_auto_reload_check() {
  [ -n "${PS1-}" ] || return
  [ -f "$HOME/.gdf/generated/init.sh" ] || return

  local _gdf_mtime
  _gdf_mtime="$(stat -c %Y "$HOME/.gdf/generated/init.sh" 2>/dev/null || stat -f %m "$HOME/.gdf/generated/init.sh" 2>/dev/null)"
  [ -n "$_gdf_mtime" ] || return

  if [ -z "${GDF_INIT_MTIME:-}" ]; then
    GDF_INIT_MTIME="$_gdf_mtime"
    return
  fi

  if [ "$GDF_INIT_MTIME" != "$_gdf_mtime" ]; then
    GDF_INIT_MTIME="$_gdf_mtime"
    source "$HOME/.gdf/generated/init.sh"
  fi
}

if [[ ";${PROMPT_COMMAND};" != *";_gdf_auto_reload_check;"* ]]; then
  if [ -n "${PROMPT_COMMAND:-}" ]; then
    PROMPT_COMMAND="_gdf_auto_reload_check;${PROMPT_COMMAND}"
  else
    PROMPT_COMMAND="_gdf_auto_reload_check"
  fi
fi
`
	case Zsh:
		return `
_gdf_auto_reload_check() {
  [ -n "${PS1-}" ] || return
  [ -f "$HOME/.gdf/generated/init.sh" ] || return

  local _gdf_mtime
  _gdf_mtime="$(stat -c %Y "$HOME/.gdf/generated/init.sh" 2>/dev/null || stat -f %m "$HOME/.gdf/generated/init.sh" 2>/dev/null)"
  [ -n "$_gdf_mtime" ] || return

  if [ -z "${GDF_INIT_MTIME:-}" ]; then
    GDF_INIT_MTIME="$_gdf_mtime"
    return
  fi

  if [ "$GDF_INIT_MTIME" != "$_gdf_mtime" ]; then
    GDF_INIT_MTIME="$_gdf_mtime"
    source "$HOME/.gdf/generated/init.sh"
  fi
}

typeset -ga precmd_functions
if (( ${precmd_functions[(Ie)_gdf_auto_reload_check]} == 0 )); then
  precmd_functions=(_gdf_auto_reload_check ${precmd_functions[@]})
fi
`
	default:
		return ""
	}
}
