package cli

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/rztaylor/GoDotFiles/internal/config"
	"github.com/rztaylor/GoDotFiles/internal/platform"
	"github.com/rztaylor/GoDotFiles/internal/shell"
	"github.com/rztaylor/GoDotFiles/internal/state"
)

type fixAction struct {
	Code        string
	Description string
	Run         func() error
}

func buildFixActions(gdfDir string, findings []healthFinding) []fixAction {
	actions := make([]fixAction, 0)
	seen := map[string]bool{}

	add := func(code, description string, run func() error) {
		if seen[code] {
			return
		}
		seen[code] = true
		actions = append(actions, fixAction{
			Code:        code,
			Description: description,
			Run:         run,
		})
	}

	for _, f := range findings {
		switch f.Code {
		case "apps_dir_missing":
			add("apps_dir_missing", "Create apps directory", func() error {
				return os.MkdirAll(filepath.Join(gdfDir, "apps"), 0755)
			})
		case "profiles_dir_missing":
			add("profiles_dir_missing", "Create profiles directory", func() error {
				return os.MkdirAll(filepath.Join(gdfDir, "profiles"), 0755)
			})
		case "dotfiles_dir_missing":
			add("dotfiles_dir_missing", "Create dotfiles directory", func() error {
				return os.MkdirAll(filepath.Join(gdfDir, "dotfiles"), 0755)
			})
		case "generated_dir_missing":
			add("generated_dir_missing", "Create generated directory", func() error {
				return os.MkdirAll(filepath.Join(gdfDir, "generated"), 0755)
			})
		case "config_missing":
			add("config_missing", "Create default config.yaml", func() error {
				cfg := &config.Config{}
				return cfg.Save(filepath.Join(gdfDir, "config.yaml"))
			})
		case "state_missing":
			add("state_missing", "Create empty state.yaml", func() error {
				st := &state.State{AppliedProfiles: []state.AppliedProfile{}}
				return st.Save(filepath.Join(gdfDir, "state.yaml"))
			})
		case "generated_init_missing":
			add("generated_init_missing", "Create placeholder generated/init.sh", func() error {
				if err := os.MkdirAll(filepath.Join(gdfDir, "generated"), 0755); err != nil {
					return err
				}
				content := "#!/usr/bin/env sh\n# Generated by gdf health fix\n"
				return os.WriteFile(filepath.Join(gdfDir, "generated", "init.sh"), []byte(content), 0644)
			})
		case "rc_source_missing":
			add("rc_source_missing", "Inject GDF source line into shell RC file", func() error {
				shellName := platform.DetectShell()
				shellType := shell.ParseShellType(shellName)
				if shellType == shell.Unknown {
					return fmt.Errorf("could not detect supported shell for RC injection")
				}
				return shell.NewInjector().InjectSourceLine(shellType)
			})
		}
	}

	return actions
}

func runHealthFix(gdfDir string, w io.Writer) error {
	doctor, err := runHealthDoctorReport(gdfDir)
	if err != nil {
		return err
	}

	actions := buildFixActions(gdfDir, doctor.Findings)
	if len(actions) == 0 {
		fmt.Fprintln(w, "No auto-fixable issues found.")
		return nil
	}

	fmt.Fprintln(w, "Planned fix actions:")
	for i, action := range actions {
		fmt.Fprintf(w, "  %d. [%s] %s\n", i+1, action.Code, action.Description)
	}

	ok, err := confirmPrompt("Apply these changes? [y/N]: ")
	if err != nil {
		return err
	}
	if !ok {
		return withExitCode(fmt.Errorf("fix cancelled"), exitCodeNonInteractiveStop)
	}

	var failed int
	for _, action := range actions {
		if err := action.Run(); err != nil {
			failed++
			fmt.Fprintf(w, "✗ %s: %v\n", action.Description, err)
			continue
		}
		fmt.Fprintf(w, "✓ %s\n", action.Description)
	}

	if failed > 0 {
		return withExitCode(fmt.Errorf("%d fix action(s) failed", failed), exitCodeFixFailure)
	}

	return nil
}
